Memory
Now that you've seen how the CPU executes program code, let's work backward in the process for a moment and think about how the program code gets to the external data bus. The program itself is stored on the hard drive. In theory, you could build the computer that sends data from the hard drive directly to the CPU, but there's a problem--the hard drive is too slow. Even the ancient 8088, with its clock speed of 4.77 MHz, could conceivably process several millions lines of code every second. Modern CPUs crank out billions of lines every second. Hard drives simply can't give the data to the CPU at a fast enough speed.
Computers need some other device that takes copies of a programs from the hard drive and then sends them, one line at a time, to the CPU quickly enough to keep up with its demands. Because each line of code is nothing more than a pattern of eight ones and zeros, any device that can store ones and zeros eight-across will do. Device that in any way hold ones and zeros that the CPU accesses are known generically as memory.
Many types of devices store ones and zeros perfectly well--technically even a piece of paper counts as memory--but computers need memory that does more than just store group of eight ones and zeros. Consider this pretend program:
1. Put 2 in the AX register.
2. Put 5 in the BX register.
3. If AX is greater than BX, run line 4; otherwise, go to line 6.
4. Add 1 to the value in AX.
5. Go back to line 1.
6. Put the value of AX on the EDB.
This program has an IF statement, also called a branch by CPU makers.
The CPU needs a way to address each line of this memory--a way for the CPU to say to the memory, "Give me the next line of code" or "Give me line 6." Addressing memory takes care of another problem: the memory must store not only programs but also the result of the programs. If the CPU adds 2 + 3 and gets 5, the memory needs to store that 5 in such a way that other programs may later read that 5, or possibly even store that 5 on a hard drive. By addressing each line of memory, other programs will know where to find the data.
Memory and RAM
Memory must store not only programs, but also data. The CPU needs to be able to read and write to this storage medium. Additionally, this system must enable the CPU to jump to any line of stored code as easily as to any other line of code. All of this must be done at or at least near the clock speed of the CPU. Fortunately,  this magical device has existed for many years: random access memory (RAM). "RAM" can be view as an electronic spreadsheet, like one you can generate in Microsoft Excel. Each cell in this spreadsheet can store only a one or a zero. Each cell is called a bit. Each row in the spreadsheet is 8 bits across to match the EDB of the 8088. Each row of 8 bits is called a byte. In PCs, RAM transfers and stores data to and from the CPU in byte-sized chunks. RAM is therefore arranged in byte-sized rows. Here are the terms used to talk about quantities of bits:
- Any individual 1 or 0 = a bit
- 4 bits = a nibble
- 8 bits = a byte
- 16 bits = a word
- 32 bits = a double word
- 64 bits = a paragraph or quad word
The number of bytes of RAM varies from PC to PC. In earlier PCs, from around 1980 to 1990, the typical system would have only a few hundred thousand bytes of RAM. Today's systems often have billions of bytes of RAM.
Let's stop here for a quick reality check. Electronically, RAM looks like a spreadsheet, but real RAM is made of groups of semiconductor chips soldered onto small cards that snap into your computer. these groups of chips actually make themselves look like a spreadsheet. But for now, don't worry about real RAM and just stick with the spreadsheet idea.
The CPU accesses any one row of RAM as easily and as fast as any other row, which explains the "random access" part of RAM. Not only is RAM randomly accessible, it's also fast. By storing programs on RAM, the CPU can access and run them very quickly. RAM also stores any data that the CPU actively uses.
Computers us dynamic RAM (DRAM) for the main system memory. DRAM needs both a constant electrical charge and a periodic refresh of the circuits; otherwise, it loses data--that's what makes it dynamic rather than static in content. The refresh can cause some delays, because the CPU has to wait for the refresh to happen, but modern CPU manufacturers have clever ways to get by this issue, as you'll see later in "modern processor technology" in this chapter.
Don't confuse RAM with mass storage devices such as hard drives and flash drives. You use hard drives and flash drives to store programs and data permanently. (as known as "permanent" storage")
Address Bus
So far, the entire PC consists of only a CPU and RAM. But the CPU and the RAM need some connection so they can talk to each other. To do so, extend the external data bus from the CPU so it can talk to the RAM
Wait a minute. This is not a matter of just plugging the RAM into the EDB wires! RAM is a spreadsheet with thousands and thousands of discrete rows, and you need to look at the contents of only one row of spreadsheet at a time, right? So how do you connect the RAM to the EDB in such a way that the CPU can see any one given row but still give the CPU the capability to look at any row in RAM?
We need some type of chip between the RAM and the CPU to make the connection. The CPU needs to be able to say which row of RAM it wants, and the chip should handle the mechanics of retrieving that row of data from the RAM and putting it on the EDB. This chip comes with many names, but for right now just call it the memory controller chip (MCC).
The MCC contains special circuitry so it can grab the contents of any line of RAM and place that data or command on the EDB. This in turn enables the CPU to act on that code.
Once the MCC is in place to grab any discrete byte of RAM, the CPU needs to able to tell the MCC which line of code it needs. The CPU therefore gains a second set of wires, called the address bus, with which it can communicate with the MCC. Different CPUs have different numbers of wires (which, you will soon see, is very significant). The 8088 had 20 wires in its address bus.
By turning the address bus wires on and off in different patterns, the CPU tells the MOC which line of RAM it wants at any given moment. Every different pattern of ones and zeros on these 20 wires points to one byte of RAM. There are two big questions here. First, how many different patterns of on-and-off wires can exist with 20 wires? And second, which pattern goes to which row of RAM?
How Many Patterns?
Mathematics can answer the first question. Each wire in the address bus exists in only one of two states: on and off. If the address bus consisted of only one wire, that wire would at any given moment be either on or off. Mathematically, that gives you (pull out your old pre-algebra books) 2^1 = 2 different combinations. If you have two address bus wires, the address bus wires create 2^2 = 4 different combinations. If you have 20 wires, you would have 2^20 (or 1,048,576) combinations. Because each pattern points to one line of code and each line of RAM is one byte, if you know the number of wires in the CPU's address bus, you know the maximum amount of RAM that a particular CPU can handle.
Because the 8088 had 20-wire address bus, the most RAM it could handle was 2^20 or 1,048,576 bytes. The 8088, therefore, had an address space of 1,048,576 bytes. This is not to say that every computer with an 8088 CPU had 1,048,576 bytes of RAM. Far from it! The original IBM PC only had a measly 65,536 bytes--but that was considered plenty back in the Dark Ages of Computing in the early 1980s.
Okay, so you know that the 8088 had 20 address wires and a total address space of 1,048,576 bytes. Although this is accurate, no one uses such an exact term to discuss the address space of the 8088. Instead you say that the 8088 had one megabyte (1 MB) of address space.
What's "mega"? Well, let's get some terminology down. Dealing with computers means constantly dealing with the number of patterns a set of wires can handle. Certain powers of 2 have names used a lot in computing. The following list explains.
1 kilo = 2^10 = 1024 (abbreviated as "K")
1 kilobyte = 1024 bytes (abbreviated as "KB)
1 mega = 2^20 = 1,048,576 (abbreviated as "M")
1 megabyte = 1,048,576 bytes (abbreviated as "MB")
1 giga = 2^30 = 1,073,741,824 (abbreviated as "G")
1 gigabyte = 1,073,741,824 (abbreviated as "GB)
1 tera = 2^40 = 1,099,511,627,776 (abbreviated as "T")
1 terabyte = 1,099,511,627,776 (abbreviated as "TB")
Metric System and Computer Memory
There's a problem with that list you just read. If you asked a metric system expert for explanation, she would say that a kilo is equal to exactly 1000, not 1024! Am I lying to you?
Well, yes, I am, but not out of malice. I'm just the messenger of yet another weird aspect to computing. Here's what happened, a long time ago. In the early days computing there arose a need to talk about large values, but the words hadn't been invented. In one case, the memory address folks were trying to describe permutations. They used values based on powers of two as just described. No one has ever invented terms for 1024 or 1,048,576, so they used kilo and mega, as 1000 was close enough to 1024 and 1,000,000 was close enough to 1,048,576.
In the meantime, computer people measuring quantities such as CPU speeds and hard drive capacities didn't count with powers of two. They just needed regular 1000 for kilo and 1,000,000 for mega.
From the early 1980s until around 1990, nobody cared about this weird thing where one word could mean two values. Everything was fine until the math nerds and the attorneys started making trouble. To fix this, in 1998 the International Electrotechnical committee (IEC) invented special prefixes for binary values I call the ibis (pronounced eee-bees)
1 kibi = 2^10 = 1024 (abbreviated as "Ki")
1 mebi = 2^20 = 1,048,576 (abbreviated as "Mi")
1 gibi = 2^30 = 1,073,741,824 (abbreviated as "Gi")
1 tebi = 2^40 = 1,099,511,627,776 (abbreviated as "Ti")
To follow this revised naming convention, you should say, "the 8088 processor could address one mebibyte (MiB) of memory." The problem is that no one but math nerds use these ibis. If you buy RAM, the manufacturers use the term gigabyte even though technically they should use gibibyte. Welcome to the weird world of counting in IT. Let's get back to memory.
NOTE
The jury is still count on correct pronunciation of the ibis. You will find ardent supporters of "keebeebyte" and equally passionate supporters of "kehbeebyte". It doesn't really matter, because the rest of us just say "kilobyte".
Which pattern Goes to Which Row?
The second question is a little harder: "which pattern goes to which row of RAM?" TO understand this, let's take a moment to discuss binary counting. In binary, only two numbers exist, 0 and 1, which makes binary a handy way to work with wires that turn on and off. Let's try to count in binary: 0, 1... what's next? It's not 2-- you can only use zeros and ones. The next number after 1 is 10! Now let's count in binary to 1000: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Try counting to 10000. Don't worry; it hardly takes any time at all.
Super; you now count in binary as well as any math professor. Let's add to the concept. Stop thinking about binary for just a moment and think about good old base 10 (regular numbers). If you have the number 365, can you put zeros in front of the 365, like this: 000365? Sure you can--it doesn't change the value at all. The same thing is true in binary. Putting zeros in front of a value doesn't change a thing! Let's count again to 1000 in binary. In this case, add enough zeros to make 20 places:
00000000000000000000
00000000000000000001
00000000000000000010
00000000000000000001
00000000000000000100
00000000000000000101
00000000000000000110
00000000000000000111
00000000000000001000
Hey, wouldn't this be a great way to represent each line of RAM on the address bus? The CPU identifies the first byte of RAM on the address bus with 00000000000000000000. The CPU identifies the last RAM row with 11111111111111111111. When the CPU turns off all the address bus wires, it wants the first line of RAM; when it turns on all the wires, it wants the 1,048,576th line of RAM. Obviously, the address bus also addresses all the rows of RAM in between. So, by lighting up different patterns of ones and zeros on the address bus, the CPU can access any row of RAM it needs.
NOTE
Bits and bytes are abbreviated differently. Bits get a lowercase b, whereas bytes get a capital B. So for example, 4 Kb is 4 kilobits, but 4 KB is 4 kilobytes. The big-B little-b standard applies all the way up the food chain, so 2 Mb = 2 megabits; 2 MB = 2 megabytes; 4 Gb = 4 gigabits; 4 GB = 4 gigabytes; and so on.