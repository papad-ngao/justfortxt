Some detail from the Information tab of Text-Based UEFI on Lenovo IdeaPad Y410P:
(InsydeH20 Setup Utility, Rev. 3.7) [selected tab: "Information"]
- Product Name: Lenovo IdeaPad Y410P
- BIOS Version: 74CN44WW (V3.05)
- EC Version: 74CN44WW (V3.05)
- Lenovo SN: YB01243150
- UUID Number: 36268652-3D1B-11E3-A394-28D244341648
- CPU: Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz
- System Memory: 8192 MB
- Hard Disk: ST1000LM024 HN-M101MBB
- ODD: HL-DT-ST DVDRAM GU70N
- Windows license: STD

The Configuration tab shows a number of built-in devices that you configure or enable/disable here. Because this is a portable, it has an option to turn on/off wireless networking capabilities.
Some available configuration options from the Configuration tab of Text-Based UEFI on Lenovo IdeaPad Y410P:
(InsydeH20 Setup Utility, Rev. 3.7) [selected tab: "Configuration"]
- System Time: "[12:23:19]"
    - hint (labeled as "Item Specific Help"):
        - Hour: Valid range is from 0 to 23.
        - Minute: Vali range is from 0 to 59.
        - Second: Vali range is from 0 to 59.
        - Increase/Reduce: F6/F5
    - value: "[12:23:19]"
- System Date, current value: "[07/17/2015]"
- Wireless, selected: "[Enabled]"
- SATA Controller Mode, selected: "[AHCI]"
- Power Beep, selected: "[Disabled]"
- Always on USB, selected: "[Disabled]"
- Intel Virtual Technology, selected: "[Disabled]"
- BIOS Back Flash, selected: "[Disabled]"
- Deep S3 Function, selected: "[Disabled]"
- Graphic Device, selected: "[Discrete]"
There are two interesting options here that are covered in detail in other chapters but warrant a brief discussion now. The Intel Virtual Technology option enables or disables virtualization support for virtual machines.
A virtual machine is a powerful type of program that enables you to run a second (or third to fourth), software-based machine inside your physical PC. It re-creates the motherboard, hard drives, RAM, network adapters, and more, and is just as powerful as a real PC. To run these virtual machines, however, you'll need a very powerful PC--you are trying to run multiple PCs at the same time, after all.
To support this, CPU manufacturers have added hardware-assisted virtualization. Intel calls their version Intel Virtualization Technology (Intel VT for short), and AMD calls theirs AMD Virtualization (AMD-V) technology. This technology helps the virtual machines use your hardware more efficiently and is controlled by the BIOS. This feature is disabled by default in BIOS, so if your virtual machine requires hardware-assisted virtualiation, you'll need to enable it here.
NOTE
In future topic "Virtualization" will covers machines in gory detail. Stay tuned!
This particular laptop has built-in graphics courtesy of the Intel Core i7 processor, plus it has a dedicated add-on video card for gaming. The Graphic Device option, set here to Discrete, means to use the dedicated video card when possible. This uses more electricity than the graphics support using only the processor, but it makes for way possible gaming!
NOTE
In future topic "Display Technologies", goes into video options (and gaming) in modern systems.
The Security tab offers a lot more options for configuring BIOS security than found on the Main tab of the of the AMD-based system. You see the Administrator Password and Use Password options, but there's also an option to set a couple of different hard drive passwords.
Some available configuration options from the Security tab of Text-Based UEFI on Lenovo IdeaPad Y410P:
(InsydeH20 Setup Utility, Rev. 3.7) [selected tab: "Security"]
- Administrator Password, current value: "Not set"
- User Password, current value: "Not set"
- HDD Password, current value: "Not set"
> Set Administrator Password
    - hint (labeled as "Item Specific Help"):
        - Set or Change the Administrator Password. Passwords must be at least one character in length
        - Administrator Password must be set in order to set a Power on Password and User Password.
- Set Hard Disk Passwords
- Secure Boot, selected: "[Enabled]"
- Secure Boot Status: Enabled
- Platform Mode: User Mode
- Secure Boot Mode: Standard
- Reset to Setup Mode, selected: "[Enter]"
- Restore Factory Keys, selected: "[Enter]"

The Secure Boot feature you can see on the Security tab is a UEFI protocol that secures the boot process by requiring properly signed software. This includes boot software and software that supports specific, essential components. (See "Device Drivers" a littler later in this chapter.) Secure Boot requires an Intel CPU, a UEFI BIOS, and an operating system designed for it, such as Windows.
NOTE
Secure Boot is an example of a tool that uses drive encryption. Various types of encryption--essentially scrambling the information to make it inaccessible to bad guys--secure all sorts of processes and data in modern computing. In the future topic "Implementing Mass Storage" will discusses drive encryption specifically in more detail.
The Boot tab enables you to set boot options to determine which bootable device gets priority. Here is where you provide support for booting a USB device as well. It looks a little different from the graphical example presented earlier. See "The Boot Process" later in this chapter for more explanation.
Some available configuration options from the Boot tab of Text-Based UEFI on Lenovo IdeaPad Y410P:
(InsydeH20 Setup Utility, Rev. 3.7) [selected tab: "Boot"]
- Boot Mode, selected: "[UEFI]"
    - hint (labeled as "Item Specific Help"):
        - [UEFI]: For OS need pure UEFI.
        - [Legacy Support]: For OS need legacy support.
- USB Boot, selected: "[Enabled]"
- EFI:
    - Windows Boot Manager (ST1000LM024 HN-M101MBB)
    - EFI Network 0 for IPv4 (28-D2-44-34-16-48)
    - EFI Network 0 for IPv6 (28-D2-44-34-16-48)

Other BIOS Security Settings
Motherboard manufacturers, BIOS/UEFI writers, programmers, have implemented all kinds of security features over the years. This section mentions a couple you might run into on various motherboard (or on a certain exam in your near future).
Chassis Intrusion Detection/Notification
Many motherboards support the chassis intrusion detection/notification feature provided by the computer case, or chassis. Compabible cases contain a switch that trips when someone open the case. With motherboard support and a proper connection between the motherboard and the case, the CMOS logs whether the case has been opened and, if it has, posts a notification to the screen on the subsequent boot. How cool is that?
LoJack
Some PC manufacturers include LoJack security features in their firmware--this way, if your PC is stolen, you can track its location, install a keylogger, or even remotely shut down your computer.
Trusted Platform Module
The Trusted Platform Module (TPM) acts as a secure cryptoprocessor, which is to say that it is a hardware platform for the acceleration of cryptographic functions and the secure storage of associated information. The specification for the TPM is published by the Trusted Computing Group, an organization whose corporate members include Intel, Microsoft, AMD, IBM, Lenovo, Dell, Hewlett-Packard, and many others.
The TPM can be a small circuit board plugged into the motherboard, or it can be built directly into the chipset. The CMOS setup program usually contains settings that can turn the TPM on or off and enable or disable it.
TPMs can be used in a wide array of cryptographic operations, but one of the most common uses of TPMs is a hard disk encryption. For example, the BitLocker Drive Encryption feature of Microsoft Windows can be accelerated by a TPM, which is more secure because the encryption key is stored in the tamper-resistant TPM hardware rather than on an external flash drive. Other possible uses of TPMs include digital rights management (DRM), network access control, application exection control, and password protection.
EXAM TIP
BIOS security-related options can include TPM, passwords, Secure Boot, intrusion detection/notification, and drive encryption.
Exiting and Saving Settings
Of course, all system utilities provide some method to Save, Exit Saving Changes, or Exit Discarding Changes. Use these as needed for your situation. Exit Discarding Changes is particularly nice for those folks who want to poke around the CMOS setup utility but don't want to mess anything up. Use it!

Some available configuration options from the Exit tab of Text-Based UEFI on Lenovo IdeaPad Y410P:
(InsydeH20 Setup Utility, Rev. 3.7) [selected tab: "Exit"]
> Exit Saving Changes
    - hint (labeled as "Item Specific Help"):
        - Exit Setup and save your changes.
- Exit Discarding Changes
- Discard Changes
- Save Changes
- Load Default Settings
- OS Optimized Defaults, current value: "[Win8 64bit]"

The CMOS setup utility would meet all the needs of a modern system for BIOS if manufacturers would just stop creating new devices. That's not going to happen, of course, so let's turn now to devices that need to have BIOS loaded from elsewhere.
NOTE
People serious about tweaking UEFI settings for maximum performance (overclocking) or minimum energy use (underclocking) can use a feature in some system setup utilities to save customized settings. Various utilities call them presets or profiles--essentially it's a "save these settings as" option. If something isn't quite right with the changes, go back into setup, make some changes, and try again. If you're fiddling for the day and want to play with a stable machine, pick the profile you created that is a stable machine. See "Care and Feeding of BIOS/UEFI and CMOS" later in this chapter for the ultimate undo features.
Option ROM and Device Drivers
Every piece of hardware in your computer needs some kind of programming that tells the CPU how to talk to that device. When IBM invented the PC decades ago, they couldn't possibly have included all of the necessary BIOS routines for every conceivable piece of hardware on the system ROM chip. How could they? Most of the devices in use today didn't exist on the first PCs. When programmers wrote the first BIOS, for example, network cards, mice, and sound cards did not exist. Early PC designers at IBM understood that they could not anticipate every new type of hardware, so they gave us a few ways to add programming other than on the BIOS. I call this BYOB--Bring Your Own BIOS. You can BYOB in two ways: option ROM and device drivers. Let's look at both.
Option ROM
The first way to BYOB is to put the BIOS on the hardware device itself. A serial ATA RAID hard drive controller is basically just a card that lets you add more hard drives to a PC. The chip in the center of it with the wires coming out of the sides is a flash ROM that stores BIOS for the card. The system BIOS does not have a clue about how to talk to this card, but that's okay, because this card brings its own BIOS on what's called an option ROM chip.
More BIOS that come on option ROMs tell you that the exist by displaying information when you boot the system. Shown below is a typical example of an option ROM advertising itself.
Some detail shown from an option ROM advertising itself:
- System Memory Size: 4.0 GB, System Memory Speed: 800 MHz, Voltage: 1.5V
- Broadcom NetXtreme II Ethernet Boot Agent v5.2.7
- Copyright (C) 2000-2009 Broadcom Corporation
- All rights reserved.
- Press Ctrl-S to Configure Device (MAC Address - 0024E867D111)
- Adaptec 1225SA SATA HostRAID BIOS V6.0-0 B2328
- (c) 1998-2007 Adaptec, Inc. All Rights Reserved.
- <<< Press <Ctrl><A> for Adaptec RAID Configuration Utility! >>>
- Controller #00: Adaptec 1225SA at PCI Bus:03, Dev:00, Func: 00
- SerialNumber = 0KX0B0040013
- Loading Confuguration...
- 00:00 WDC WD20EADS-00R6B0 01.00A01, 1.81 TB Healthy, 3.0 Gb/s
- SATA JBOD- PORT-0, WDC WD20EADS-00R, 1.81 TB, Legacy
- 1 JBOD Device(s) Found.

In the early days of the PC, you could find all sorts of devices with BIOS on option ROMs. Today, option ROMs have mostly been replaced by more flexible software methods (more on device driver sofware in the next section), with one major exception: video cards. Every video card made today contains its own BIOS. Option ROM work well but are hard to upgrade. For this reason, most hardware relies on software BYOB.
Device Drivers
A device driver is a file stored on the PC's hard drive that contains all of the commands necessary to talk to whatever device it was written to support. All operating systems employ a method of loading these device drivers into RAM every time the system boots. They know which device drivers to install by reading a file (or files) that lists which device drivers the system needs to load at boot time. All operating systems are designed to look at this list early on in the boot process and copy the listed files into RAM, thereby giving the CPU (and the OS) the capability to communicate with the hardware supported by the device driver.
Device drivers come with the device when you buy it. When you buy almost any device for your computer, that new sound card or monitor or whatever usually comes with some kind of media, often an optical disc, that holds all of the necessary device drivers (and usually a bunch of extra goodies).
In manay cases you may not want to use installation media and just let the OS handle things. All operating systems use online tools to detect and automatically install device drivers. You might want to add or remove device drivers manually at times. Windows stores drivers (and a lot more) in a database called the Registry, which we'll talk about in detail in future topic "Windows Under the Hood". Techs rarely deal directly with the registry, but rather instead indirectly through the Device Manager utility.
BIOS, BIOS Everywhere!
As you should now understand, every piece of hardware on a system must have an accompanying program that provides the CPU with the code necessary to communicate with that particular device. This code may reside on the system ROM on the motherboard, on ROM on a card, or in a device driver files on the hard drive loaded into RAM at boot. BIOS is everywhere on your system, and you need to deal with it occasionally.
Power-On Self Test (POST)
BIOS isn't the only program on system ROM. When the computer is turned on or reset, it initiates a special program, also stored on the system ROM chip, called the power-on self test (POST). The POST program checks out the system every time the computer boots. To perform this check, the POST sends out a command that says to all of the devices, "Check yourselves out!". All of the standard devices in the computer then run their own built-in diagnostic--the POST doesn't specify what they must check. The quality of the diagnostic is up to the people who made that particular device.
Let's consider the POST for a moment. Suppose some device--let's say it's the keyboard controller chip--runs its diagnostic and determines that it is not working properly. What can the POST do about it? Only one thing really: tell the human in front of the PC! So how does the computer tell the human? PCs convey POST information to you in two ways: beep codes--if anything wrong. By using beep codes before and during the video test, the computer could communicate with you. (If a POST error occurs before the video is available, obviously the error must manifest itself as beeps, because nothing can display on the screen.) The meaning of beep code you'd hear varied among different BIOS manufacturers. You could find the beep codes for a specific motherboard in its motherboard manual.
NOTE
CompTIA refers to beep codes as POST code beeps.
Most modern PCs have only two beep codes: one for bad or missing video (one long beep followed by two or three short beeps), and one for bad or missing RAM (a single beep that repeats indefinitely).
CAUTION
You'll find lots of online documentation about beep codes, but it's usually badly outdated.
You'll hear three other beeps sequences on most PCs (although they're not officially beep codes). At the end of a successful POST, the PC produces one or two short beeps, simply to inform you that all is well. Most systems make a rather strange noise when the RAM is missing or very seriously damaged. Unlike traditional beep codes, this code repeats until you shut off the system. Finally, your speaker might make beeps for reasons that aren't POST or boot related. One or the more common is a series of short beeps after the system's been running for a while. That's the CPU alarm telling you the CPU is approaching its high heat limit.
Text Errors
After the video has tested okay, any POST errors display on the screen as text errors. If you get a text error, the problem is usually, but not always, self-explanatory (for example, simply saying "Keyboard failure"). Text erorors are far more useful than beep codes, because you can simply read the screen to determine the bad device.

POST test error messages at the '<=':
"F10 = System Services"
"F11 = BIOS Boot Manager"
"F12 = PXE Boot"
"Keyboard Failure" <=
"One 1.86 GHz Dual-core Processor, Bus Speed:4.80 GT/s, L2/L3 Cache: 512 KB/4 MB"
"System running at 1.86 GHz"
"System Memory Size: 4.0 GB, System Memory Speed: 800 MHz, Voltage: 1.5V"
POST cards
Beep codes, numeric codes, and text error codes, although helpful, can sometimes be misleading. Worse than that, an inoperative device can somtimes disrupt the POST, forcing the machine into an endless loop. This causes the PC to act dead--no beeps and nothing on the screen. In this case, you need a device, called a POST card, to monitor the POST and identify which piece of hardware is causing the trouble.
POST cards are simple cards that snap into expansion slots on your system. A small, two-character light-emitting diode (LED) readout on the card indicates which device the POST is currently testing.
POST cards used to be essential tools for techs, but today I use them only when I have a "dead" PC to determine at which level it's dead. If the POST card shows no reading, I know the problem is before the POST and must be related to the power, the CPU, the RAM, or the motherboard. If the board posts, then I know to look at more issues, such as the drives and so on.
The Boot Process
All PCs need a process to begin their operations. Once your feed power to the PC, the tight interrelation of hardware, firmware, and software enables the PC to start itself, to "pull itself up by the bootstraps" or boot itself.
When you first power on the PC, the power supply circuitry tests for proper voltage and then sends a signal down a special wire called ther power good wire to awaken the CPU. The moment the power good wire wakes it up, every Intel and clone CPU immediately sends a built-in memory address via its address bus. This special address is the same on every Intel and clone CPU, from the oldest 8086 to the most recent microprocessor. This address is the first line of the POST program on the system ROM! That's how the system starts the POST. After the POST has finished, there must be a way for the computer to find the programs on the hard drive to start the operating system. What happens next differs between the old BIOS way and the UEFI way.
In the older BIOS environment, the POST passes control to the last BIOS function: the bootstrap loader. The bootstrap loader is little more than a few dozen lines of BIOS code tacked to the end of the POST program. Its job is to find the operating system. The bootstrap loader reads CMOS information to tell it where to look first for an operating system. Your PC's CMOS setup utility has an option that you configure to tell the bootstrap loader which devices to check for an operating system and in which order--that's the boot sequence.
detail that can be visible in CMOS boot sequence:
- "> Hard Disk Boot Priority [Press Enter]"
- "First Boot Device [CDROM]"
- "Second Boot Device [Hard Disk]"
- "Third Boot Device [CDROM]"

Almost all storage devices--hard disk drives, solid-state drives, CDs, DVDs, and USB thub drives--can be configured to boot an operating system by setting aside a specific location called the boot sector. If the device is bootable, its boot sector contains special programming designed to tell the system where to locate the operating system. Any device with a functional operating system is called a bootable disk or a system disk. If the bootstrap loader locates a good boot sector, it passes control to the operating system and removes itself from memory. If it doesn't, it goes to the next device in the boot sequence you set in the CMOS setup utility. The boot sequence is an important tool for techs because you can set it to load in special bootable devices so you can run utilities to maintain PCs without using the primary operating system.
In UEFI systems, the POST hands control of the boot process to the Boot Manager, which checks the boot configuration, and then loads the operating system boot loader directly. There's no need for scannning for a boot sector or any of that. UEFI firmware stores the boot manager and boot configuration.
detail that can be visible in UEFI Boot Mode with Boot Manager options displayed:
- "Boot Option Priorities"
    - "Boot Option #1: 'UEFI: Sand...'"
    - "Boot Option #2: 'SATA  PM...'"
- "Boot Override"
    - "> SATA  PM: ST9320421ASG"
    - "> SanDisk U3 Titanium 2.18"
    - "> UEFI: SanDiskU3 Titanium 2.18"
- "> Hard Drive BBS Priorities"
- "(Version 2.00.1201. Copyright (C) 2011 American Megatren...)"
NOTE
If you put an old-style BIOS bootable disk in a UEFI system, the system will most likely drop into BIOS compatibility mode and boot just like the old days.
Some BIOS include a feature that enables a PC to use a preboot execution environment (PXE). A PXE enables you to boot a PC without any local storage by retrieving an OS from a server over a network. You'll see more on PXE when we talk about installing Windows in future topic, "Building a PC".
Care and Feeding of BIOS/UEFI and CMOS
BIOS and CMOS are areas in your PC that you don't go to very often. BIOS itself is invisible. The only real clue you have that it even exists is the POST. The CMOS setup utility, on the other hand, is very visible if you start it. Most CMOS setup utilities today work acceptably well without ever being touched. You're an aspiring tech, however, and all self-respecting techs start up the CMOS setup utility and make changes. That's when most CMOS setup utility problems take place.
If you mess with the CMOS setup utility, remember to make only as many changes at one time as you can remember. Document the original settings and the changes on a piece of paper or take a photo so you can put things back if necessary. Don't make changes unless you know what they mean! It's easy to screw up a computer fairly seriously by playing with CMOS settings you don't understand.
Default/Optimized Settings
Every CMOS setup utility has a couple of reset options, commonly called Load Default Settings and OS Optimized Defaults. These options keep you from having to memorize all of those weird settings you'll never touch. Default of Fail-Safe sets everything to very simple settings--you might occasionally use this setting when very low-level problems such as freeze-ups occur and you've checked more obvious areas first. Optimized sets the CMOS to the best possible speed/stability for the system. You would this option after you've tampered with the CMOS too much and need to put it back like it was!
Options for resetting CMOS (at the "<="), as seen from some available configuration options from the Exit tab of Text-Based UEFI on Lenovo IdeaPad Y410P:
(InsydeH20 Setup Utility, Rev. 3.7) [selected tab: "Exit"]
> Exit Saving Changes
    - hint (labeled as "Item Specific Help"):
        - Exit Setup and save your changes.
- Exit Discarding Changes
- Discard Changes
- Save Changes
- Load Default Settings <=
- OS Optimized Defaults, current value: "[Win8 64bit]" <=

Clearing CMOS RTC RAM
You read about the process for clearing system settings, but the process is worth repeating here. When you mess up a setting (by overclocking too much or disabling something that should have remained enabled--or vice versa) that renders the computer dead, you can reset the CMOS RTC RAM back to factory defaults and start over.
Almost every motherboard has a dedicated set of wires called CLRTC or something similar.
NOTE
Many techs use older language to describe the reset CMOS RTC RAM, simply CMOS clear, describing both the process and the motherboard option.
Turn off and unplug the computer, then open the case to access the motherboard. Find the CMOS RTC clear wires. Move the shunt (the little plastic and metal jumper thing) from wires 1 and 2 to wires 2 and 3. Wait for 10 seconds and then move the shunt back to the default position. Plug in and boot the system.

-- 334 --